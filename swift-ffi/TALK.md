Help! There are 5 runtimes in my Haskell x Swift interop

1. Template Haskell runtime
    - Generate Moat instances, Marshaling instances, and functions that when
      run produce Swift code for these types
    - Also delete stale Swift file for the module being recompiled
2. Plugin runtime
    - Collect all functions that produce code using annotations
    - Evaluate in an interactive session where the current module gets loaded
      the functions that generate Swift code
    - Write the generated Swift code to disk
    - We need a plugin to eval the code generated by TemplateHaskell, since we couldn't
      do genSwiftCode @(type) without requiring the user to write down the full
      type because we can't reify the type, generate code using the reified
      type at compile time (because reification yields a Q Exp), and then even
      execute it, all in the same splice).
3. Gen swift code runtime (eval generator code in interpreter in plugin)
    - For datatypes, do necessary conversions to Moat instances and pretty
      print the types and data
    - For functions, convert to Moat types and generate for each argument and return value, using ToSwift's
      toHaskell/fromHaskell, the Swift code that encodes/decodes these
      arguments plus a call to the foreign function exported from Haskell.
4. Cabal install time using SetupHooks
    - Create the modulemap describing the Haskell dependencies of the Swift library
    - Produce a Swift library from the built Haskell library, modulemap, generated C
      headers of foreign exports, and generated Swift modules.
5. Swift program execution runtime
    - Finally, the code runs!
