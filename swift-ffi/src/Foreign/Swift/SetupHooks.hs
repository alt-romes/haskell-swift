{-# LANGUAGE RecordWildCards, DuplicateRecordFields, QuasiQuotes #-}
-- | A 'SetupHooks' module for when using 'Foreign.Swift.Lib' to automatically
-- produce a Swift library when building a Haskell library
module Foreign.Swift.SetupHooks where

import Distribution.XCFramework.SetupHooks (xcframeworkHooks)
import qualified Data.ByteString.Char8 as B
import Distribution.Simple.SetupHooks
import Distribution.Types.UnitId
import qualified Distribution.ModuleName as ModName
import Foreign.Swift.Lib
import System.FilePath
import Control.Monad
import System.Directory
import Distribution.Compiler (PerCompilerFlavor(PerCompilerFlavor))
import qualified Data.List as List
import Data.String.Interpolate
import Distribution.Pretty (prettyShow)

foreignSwiftSetupHooks :: String {-^ Swift library name -} -> SetupHooks
foreignSwiftSetupHooks libName = let xcfPath = buildDir </> libName <.> "xcframework" in
  xcframeworkHooks xcfPath
  <> noSetupHooks
    { configureHooks = noConfigureHooks
      { preConfComponentHook = Just setStubDir
      }
    , buildHooks = noBuildHooks
      { preBuildComponentRules = Nothing
          -- todo: delete existing distribution files before writing on top? Or just make sure to always write to a temp dir...
          -- maybe select folder where to put artifacts too (e.g. with env var)
      , postBuildComponentHook = Just $ postBuild libName
          
      }
    }

setStubDir :: PreConfComponentInputs -> IO PreConfComponentOutputs
setStubDir PreConfComponentInputs{..} = do
  let with_stub = emptyBuildInfo
        -- { {-ghc--}options = PerCompilerFlavor ["-stubdir="++includeDir] []
        -- }
  return PreConfComponentOutputs
    { componentDiff = buildInfoComponentDiff (componentName component) with_stub }

postBuild :: String -> PostBuildComponentInputs -> IO ()
postBuild libName PostBuildComponentInputs{..} = do
  let modules = case targetInfo of
        TargetInfo{targetComponent=CLib Library{libBuildInfo, exposedModules}}
          -> exposedModules ++ otherModules libBuildInfo
        TargetInfo{targetComponent=CFLib ForeignLib{foreignLibBuildInfo}}
          -> otherModules foreignLibBuildInfo
        _ -> []
  let possibleModPaths = map ((<.> "swift") . (swiftSourcesDir </>) . ModName.toFilePath) modules

  -- Keep only modules that are swift files that do exist
  swiftMods <- filterM (\(path, _mod) -> doesFileExist path) $ zip possibleModPaths modules

  forM_ swiftMods $ \(path, modl) -> do
    contents <- B.readFile path
    B.writeFile path . (<> contents) $ B.unlines $ map B.pack
      [ "// This file is automatically generated by swift-ffi"
      , "// Do not edit this file directly!"
      , ""
      , "import Foundation"
      , "import Haskell.Foreign.Exports" -- all foreign exports from the xcframework of the target library are here
      , ""
      , "enum HsFFIError: Error {"
      , "    case requiredSizeIs(Int)"
      , "    case decodingFailed(String, Error)"
      , "}"
      , ""
      , "public enum HaskellException: Error {"
      , "    case exception(String)"
      , "}"
      , ""
      ]

  -- TODO: Put each module in a separate folder with the same name of the
  -- module because in Swift the hierarchy is per-folder, and all modules in
  -- the same folder are folded into the same namespace. (As in, do
  -- `Foreign/Cob/Cob.swift` rather than `Foreign/Cob.swift`)

  -- The foreign lib is neat bc we can keep the FFI part outside of the core library.
  -- What are the drawbacks of the dylib approach? can we still package?
  -- What would it take to implement fully static in cabal as a support flib type?

  -- HOW TO DO IT: Build an XCFramework with path to RTS headers and to foreign
  -- library static archive:
  -- xcodebuild -create-xcframework
  -- -library ../dist-newstyle/build/aarch64-osx/ghc-9.10.1/cob-swift-library-0.1.0.0/build/libHScob-swift-library-0.1.0.0-inplace.a
  -- -headers /nix/store/s3qv9ki02767wm20irnmfz805qgwi68i-libffi-39-dev/include
  -- -headers /nix/store/0563gdnsfhwch8fvlrzxzc77qz8dna2q-ghc-9.10.1/lib/ghc-9.10.1/lib/../lib/aarch64-osx-ghc-9.10.1/rts-1.0.2/include
  -- -output _build/CobSwiftLib.xcframework

  let packageFile = buildDir </> "Package.swift"
  -- let swiftLibName = getHSLibraryName $ componentUnitId $ targetCLBI targetInfo
  -- let swiftLibName = case targetCLBI targetInfo of
  --       LibComponentLocalBuildInfo{..} -> prettyShow componentCompatPackageName
  --       other -> reverse $ takeWhile (/= ':') $ reverse -- drop e.g. "flib" in "flib:actual-name"
  --                   $ prettyShow $ componentLocalName other
  B.writeFile packageFile $ [__i|
    // swift-tools-version: 6.1
    import PackageDescription
    
    let package = Package(
        name: "#{libName}",
        platforms: [
            .macOS(.v14)
        ],
        products: [
            .library(name: "#{libName}", targets: ["#{libName}"])
        ],
        targets: [
            .target(name: "#{libName}", dependencies: ["HaskellLib"], path: "Sources/Swift"),
            // This dependency on the xcframework makes the RTS headers available
            // and the Haskell foreign exports too, because the xcframework bundles
            // the library and RTS headers with the binary of the Haskell built library.
            .binaryTarget(
                name: "HaskellLib",
                path: "#{libName}.xcframework"
            )
        ]
    )
  |]
  
  -- // This dependency on the xcframework basically makes the RTS headers available
  -- // to the Haskell foreign exports because the xcframework bundles the RTS api
  -- // with the static lib for the foreign lib.
  -- 

  print ("Post build!", swiftMods)

-- It looks like to package the Haskell dylib/static archive as a library we may want to use XCFrameworks:
-- - https://developer.apple.com/documentation/xcode/creating-a-multi-platform-binary-framework-bundle
-- - https://developer.apple.com/documentation/xcode/distributing-binary-frameworks-as-swift-packages
-- - https://developer.apple.com/videos/play/wwdc2019/416/
-- Or maybe just .binaryTarget?
-- - https://docs.swift.org/package-manager/PackageDescription/PackageDescription.html
--
-- Also maybe target.linkerSettings:?

includeDir :: FilePath
includeDir = haskellSourcesDir </> "include"

modNameString :: ModName.ModuleName -> String
modNameString = List.intercalate "." . ModName.components
