{-# LANGUAGE RecordWildCards, DuplicateRecordFields #-}
-- | A 'SetupHooks' module for when using 'Foreign.Swift.Lib' to automatically
-- produce a Swift library when building a Haskell library
module Foreign.Swift.SetupHooks where

import qualified Data.ByteString.Char8 as B
import Distribution.Simple.SetupHooks
import qualified Distribution.ModuleName as ModName
import Foreign.Swift.Lib
import System.FilePath
import Control.Monad
import System.Directory
import Distribution.Compiler (PerCompilerFlavor(PerCompilerFlavor))
import qualified Data.List as List

foreignSwiftSetupHooks :: SetupHooks
foreignSwiftSetupHooks = noSetupHooks
  { configureHooks = noConfigureHooks
    { preConfComponentHook = Just setStubDir
    }
  , buildHooks = noBuildHooks
    { preBuildComponentRules = Nothing
        -- todo: delete existing distribution files before writing on top? Or just make sure to always write to a temp dir...
        -- maybe select folder where to put artifacts too (e.g. with env var)
    , postBuildComponentHook = Just postBuild
        
    }
  }

setStubDir :: PreConfComponentInputs -> IO PreConfComponentOutputs
setStubDir PreConfComponentInputs{..} = do
  let with_stub = emptyBuildInfo
        { {-ghc--}options = PerCompilerFlavor ["-stubdir="++includeDir] []
        }
  return PreConfComponentOutputs
    { componentDiff = buildInfoComponentDiff (componentName component) with_stub }

postBuild :: PostBuildComponentInputs -> IO ()
postBuild PostBuildComponentInputs{..} = do
  let modules = case targetInfo of
        TargetInfo{targetComponent=CLib Library{libBuildInfo, exposedModules}}
          -> exposedModules ++ otherModules libBuildInfo
        TargetInfo{targetComponent=CFLib ForeignLib{foreignLibBuildInfo}}
          -> otherModules foreignLibBuildInfo
        _ -> []
  let possibleModPaths = map ((<.> "swift") . (buildDir </>) . ModName.toFilePath) modules

  -- Keep only modules that are swift files that do exist
  swiftMods <- filterM (\(path, _mod) -> doesFileExist path) $ zip possibleModPaths modules

  forM_ swiftMods $ \(path, modl) -> do
    contents <- B.readFile path
    B.writeFile path . (<> contents) $ B.unlines $ map B.pack
      [ "// This file is automatically generated by swift-ffi"
      , "// Do not edit this file directly!"
      , ""
      , "import Foundation"
      , "import Haskell." ++ modNameString modl ++ "_stub"
      , ""
      , "enum HsFFIError: Error {"
      , "    case requiredSizeIs(Int)"
      , "}"
      , ""
      ]

  -- Write Swift module map which imports all include headers
  let modMapPath = buildDir </> "Haskell.modulemap"

  B.writeFile modMapPath $ B.unlines $ map B.pack
    [ "// This file is automatically generated by swift-ffi"
    , "// Do not edit this file directly!"
    , ""
    , "module Haskell {"
    , "    umbrella \"" ++ includeDir ++ "\""
    , ""
    , "    explicit module * {"
    , "        export *"
    , "    }"
    , "  }"
    , ""
    ]

  print ("Post build!", swiftMods)

includeDir :: FilePath
includeDir = buildDir </> "include"

modNameString :: ModName.ModuleName -> String
modNameString = List.intercalate "." . ModName.components
